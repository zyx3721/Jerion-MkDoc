# docker概念



## **一、docker基本概念**

​		Docker是一个能把开发的应用程序自动部署到容器的开源引擎，由docker公司团队编写，基于Apache2.0开源授权协议发行。



## **二、docker解决的问题**

​		使用docker，开发人员只需要关心容器中运行的应用程序，运维人员只需要关心如何管理容器。

​		docker设计目的之一就是加强开发人员写代码的开发环境和应用程序要部署的生成环境的一致性，从而降低”开发时一切正常，肯定是运维的问题“的风险。

​		docker具有快速、高效的开发生命周期，它能缩短代码从开发、测试到部署、上线运行的周期，让应用程序具备可移植性，易于构建，并易于协作。

​		docker鼓励面向服务的架构，docker推荐单个容器只运行一个应用程序，这样可形成分布式的应用程序模型。

​		在这种模型下，应用程序或服务可表示为一系列内部互联的容器，从而使分布式部署应用程序，扩展或调试应用程序变得非常简单，同时提高了程序的内省性。（当然也可一个容器运行多个进程的应用程序）



## **三、dokcer架构**

​		docker是采用（C/S）架构程序，客户端只需要向docker服务器或守护进程发出请求，服务器和守护进程将完成所有工作并返回结果。



## **四、docker组件（三件套）**

​		images镜像

​		Registry仓库

​		container容器

### **4.1 images镜像**

​		镜像是docker世界的基石，用户基于镜像来运行自己的容器，镜像也是dokcer生命周期中的构建部分，镜像是基于联合文件系统的一种层式的结构，有一系列指令一步一步构建出来。例如：

- 添加一个文件

- 执行一个命令

- 打开一个端口

​		也可以把镜像当作容器的"源代码"，镜像体积很小，易于分享、存储和更新。

### **4.2 Rigistry仓库**

​		docker用Rigistry来保存用户构建的镜像，Registry分公共和私有两种，docker公司运营的公共Registry叫Docker Hub，用户也可以在docker Hub注册账号，分享并保存自己的镜像。有些私有镜像包含有源代码或专利信息等，或者只在组织、团队内部可见的镜像。也可以架设自己的私有Rigistry，私有Rigistry可受到防火墙的保护，满足一些组织的特殊需求。

### **4.3 container容器**

​		容器是基于镜像启动起来的，容器中可以运行一个或多个进程。docker可以帮助你构建和部署容器，只需要把应用程序或服务打包放进容器即可。我们可以认为，镜像是docker生命周期中构建或打包阶段，而容器则是启动或执行阶段。总结起来，docker容器就是：

- 一个镜像格式；
- 一系列标准的操作；
- 一个执行环境

​		docker借鉴了标准集装箱的概念，标准集装箱将货物运往世界各地，docker将这个模型运用到自己的设计哲学中，唯一不同是，集装箱运输货物，而docker运输软件。

​		每个容器都包含一个软件镜像，也就是容器的"货物"，与真正 的货物一样，容器里的软件镜像可以进行一些操作，例如：镜像可以被创建、启动、关闭、重启以及销毁。docker执行上述操作时，不关心里面有什么，不管是web服务器，还是数据库，或者应用服务器，所有容器都按照相同的方式将内容"装载"进去。

​		docker不关心你要把容器运到何方，可以在笔记本构建容器，上传到Rigistry，然后找个物理或虚拟服务器测试，再把容器部署到主机集群中去。像标准集装箱一样，dokcer容器易于替换，可以叠加，易于分发，并且尽量通用。

​		使用docker，可以快速构建一个应用程序服务器、一个消息总线、一套实用工具、一个持续集成（CI）测试环境或者任意一种应用程序、服务或工具。



## **五、docker能做什么**

​		docker容器可以为各种测试环境提供很好的沙盒环境，并且，容器具有"标准性"的特征，非常适合为服务创建构建块。docker应用场景如下：

- 加速本地开发和构建流程，使其更加高效、更加轻量化，本地开发人员可以构建、运行并分享容器，容器可以在开发环境中构建，然后轻松提交到测试环境中，并最终进入生产环境。

- 能够让独立服务或应用程序在不同的环境中，得到相同的运行结果。这点在面向服务的架构和重度依赖微型服务的部署中尤其实用。

- 用docker创建隔离的环境来进行测试。例如，用Jenkins CI这样的持续集成工具启动一个用于测试的容器。

- docker可以让开发者在本机构建一个复杂的程序或架构来进行测试，而不是一开始就在生产环境部署、测试。

- 构建一个多用户的平台即服务（PaaS）基础设施。

- 为开发、测试提供一个轻量级的独立沙盒环境，或者将独立的沙盒环境用户技术教学，如shell、编程教学。

- 提供软件即服务（SaaS）应用程序，如Memcached即服务。

- 高性能、超大规模的宿主机部署。

  

## **六、Docker与配置管理**

​		自动化运维工具：Ansible、Puppet、chef。docker包含一套镜像构建和镜像管理的解决方案，现代配置管理工具的原动力之一就是"黄金镜像"模型。 然而，使用黄金镜像的结果就是充斥了大量、无管理状态的镜像，镜像数量庞大、版本混乱不堪。随着镜像使用，不确定性、环境混乱加剧，镜像本身也越笨重，最终不得不手动修正镜像不合符设计和难以管理的配置层，因为底层的镜像缺乏适当的灵活性。

​		与传统镜像相比，docker显得轻松，镜像是分层的，可以对其进行迅速迭代，数据表明，docker的特性确实可以减轻许多传统镜像管理的麻烦，docker现在还难以完全取代配置管理工具，但是从幂等性和内省性来看。取得了非常好的效果。

​		docker本身需要在主机上安装、管理和部署，主机也需要被管理起来，这样，docker容器需要编配、管理和部署，也经常需要与外部服务和工具通信，而这些恰恰是配置管理工具所擅长。

​		docker显著的特点：对不同宿主机、应用程序和服务，会表现出不同的特性与架构，docker可以是短生命周期的，也可以用于恒定的环境。可以用一次即销毁，也可以提供持久的服务。这些行为不会增加docker的复杂性，也不会和配置管理工具产生重合。基于这些行为，基本不需要担心管理状态的持久性，也不必担心状态的复杂性，因为容器的生命周期往往比较短，而重建容器的代价通常也比传统的状态修复要低。

​		当然，并非所有的基础设施都具备这样的"特性"，在未来一段时间，docker这种与理想化的工作负载可能会与传统的基础设备部署共存一段时间。长期运行的设备主机仍是很多组织中具有不可替代的地位，由于多样化的管理需求，以及管理docker的需求，在绝大多数组织中，docker和配置管理工具可能都需要部署。

## **七、Docker的技术组件**

​		docker可以运行于任何现代linux内核的x64主机，推荐内核时3.8及以上，docker开销低，可以用于台式机、笔记本。

​		一个原生的linux容器格式，docker称为libcontainer，libcontainer也是现在dokcer容器的默认格式。

​		linux内核命名空间（namespace），用于隔离文件系统、进行和网络。

- 文件隔离系统：每个容器都有自己的root文件系统。

- 进程隔离：每个容器都运行在自己的进程环境中

- 网络隔离：容器间的虚拟网络接口和IP地址都是分开的。

- 资源隔离和分组：使用cgroups（即control group，linux内核特性之一）将cpu和内存之类的资源独立分配给每个docker容器。

- 写时复制：文件系统都是通过写时复制创建的，这就意味着文件系统时分层的、快速的、而且占用的磁盘空间更小。

- 日志：容器产生的STDOUT、STDERR和STDIN这些IO流会被收集并记入日志，用来进行日志分析和故障排错。

- 交互式SHELL：用户可以创建一个伪tty终端，将其连接到STDIN，为容器提供一个交互式的shell。

  

## **七、Docker资源**

​		[Docker官方主页](https://www.docker.com/)

[		Docker Hub](https://www.hub.docker.com/)

​		[Docker官方文档](https://docs.docker.com/)

​		[Docker官方博客](https://www.docker.com/blog/)



## **八、Docker与虚拟机对比**

### **8.1 虚拟机缺点**

​		虚拟机（virtual machine）就是带环境安装的一种解决方案。

​		它可以在一种操作系统里面运行另一种操作系统，比如在Windows10系统里面运行Linux系统CentOS7。应用程序对此毫无感知，因为虚拟机看上去跟真实系统一模一样。

​		原来：传统虚拟机技术基于主操作系统上的虚拟机管理系统（VirtualBox 和 VMWare等），创建虚拟机（虚拟出各种硬件）。在虚拟机上安装从操作系统，在从操作系统种安装部署各种应用。

​		缺点：资源占用多，冗余步骤多，启动慢。



### **8.2 Docker优点**

​		Linux 容器是与系统其他部分隔离开的一系列进程，从另一个镜像运行，并由该镜像提供支持进程所需的全部文件。容器提供的镜像包含了应用的所有依赖项，因而在从开发到测试再到生产的整个过程中，它都具有可移植性和一致性。

​		Linux 容器不是模拟一个完整的操作系统而是对进程进行隔离。有了容器，就可以将软件运行所需的所有资源打包到一个隔离的容器中。容器与虚拟机不同，不需要捆绑一整套操作系统.

​		Docker 容器是在操作系统层面上实现虚拟技术，直接复用本地主机操作系统，虚拟机则是在硬件层面实现实现虚拟化。这使得 Dokcer 占用体积小、启动速度快。



### **8.3 Docker 来了什么变化**

- 一次构建，随处运行；
- 更快速的应用交付和部署，通过加载镜像运行即可；
- 更便捷的扩容和缩容，使应用扩容由原来的天级变为分钟级甚至秒级；
- 更简单的系统运维，运维同学不再受环境配置的困扰；
- 更高效的计算资源利用，一台物理机可以运行多个容器实例，大大提升物理服务器的 CPU 和内存的利用率。